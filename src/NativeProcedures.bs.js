// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var HeadProcException = Caml_exceptions.create("NativeProcedures-ReactHooksTemplate.HeadProcException");

function procToString(p) {
  if (p) {
    return "-";
  } else {
    return "+";
  }
}

function flattenProcBranch(t) {
  switch (t.tag | 0) {
    case 0 : 
    case 1 : 
        return /* :: */[
                t,
                /* [] */0
              ];
    case 2 : 
        return List.concat(/* :: */[
                    flattenProcBranch(t[0]),
                    /* :: */[
                      flattenProcBranch(t[1]),
                      /* [] */0
                    ]
                  ]);
    
  }
}

function isProcBranch(t) {
  switch (t.tag | 0) {
    case 0 : 
    case 1 : 
        return false;
    case 2 : 
        var match = t[0];
        switch (match.tag | 0) {
          case 0 : 
              if (match[0].tag === 3) {
                return true;
              } else {
                return false;
              }
          case 1 : 
          case 2 : 
              return false;
          
        }
    
  }
}

function makeProcBranch(t) {
  var match = isProcBranch(t);
  if (match) {
    var match$1 = flattenProcBranch(t);
    if (match$1) {
      var match$2 = match$1[0];
      switch (match$2.tag | 0) {
        case 0 : 
            var match$3 = match$2[0];
            if (match$3.tag === 3) {
              return /* Proc */[
                      match$3[0],
                      match$1[1]
                    ];
            } else {
              throw HeadProcException;
            }
        case 1 : 
        case 2 : 
            throw HeadProcException;
        
      }
    } else {
      throw HeadProcException;
    }
  } else {
    return /* NotProc */0;
  }
}

function $$eval(t) {
  var match = makeProcBranch(t);
  if (match) {
    var args = match[1];
    if (match[0] || !args) {
      return /* NoResult */Block.__(1, [t]);
    } else {
      var match$1 = args[0];
      switch (match$1.tag | 0) {
        case 0 : 
            var match$2 = match$1[0];
            if (match$2.tag) {
              return /* NoResult */Block.__(1, [t]);
            } else {
              var match$3 = match$2[0];
              if (match$3.tag) {
                return /* NoResult */Block.__(1, [t]);
              } else {
                var match$4 = args[1];
                if (match$4) {
                  var match$5 = match$4[0];
                  switch (match$5.tag | 0) {
                    case 0 : 
                        var match$6 = match$5[0];
                        if (match$6.tag) {
                          return /* NoResult */Block.__(1, [t]);
                        } else {
                          var match$7 = match$6[0];
                          if (match$7.tag || match$4[1]) {
                            return /* NoResult */Block.__(1, [t]);
                          } else {
                            return /* Result */Block.__(0, [/* Token */Block.__(0, [/* Primitive */Block.__(0, [/* Int */Block.__(0, [match$3[0] + match$7[0] | 0])])])]);
                          }
                        }
                    case 1 : 
                    case 2 : 
                        return /* NoResult */Block.__(1, [t]);
                    
                  }
                } else {
                  return /* NoResult */Block.__(1, [t]);
                }
              }
            }
        case 1 : 
        case 2 : 
            return /* NoResult */Block.__(1, [t]);
        
      }
    }
  } else {
    return /* NoResult */Block.__(1, [t]);
  }
}

function evalHelper(t) {
  if (t.tag) {
    var match = t[0];
    switch (match.tag | 0) {
      case 0 : 
          return /* NoResult */Block.__(1, [/* Token */Block.__(0, [match[0]])]);
      case 1 : 
          var x = match[0];
          var e = evalHelper(/* NoResult */Block.__(1, [match[1]]));
          if (e.tag) {
            return /* NoResult */Block.__(1, [/* Abstraction */Block.__(1, [
                          x,
                          e[0]
                        ])]);
          } else {
            return /* Result */Block.__(0, [/* Abstraction */Block.__(1, [
                          x,
                          e[0]
                        ])]);
          }
      case 2 : 
          var t2 = match[1];
          var t1 = match[0];
          var match$1 = $$eval(/* Application */Block.__(2, [
                  t1,
                  t2
                ]));
          if (match$1.tag) {
            var match$2 = evalHelper(/* NoResult */Block.__(1, [t1]));
            var match$3 = evalHelper(/* NoResult */Block.__(1, [t2]));
            if (match$2.tag) {
              var r1 = match$2[0];
              if (match$3.tag) {
                return /* NoResult */Block.__(1, [/* Application */Block.__(2, [
                              r1,
                              match$3[0]
                            ])]);
              } else {
                return /* Result */Block.__(0, [/* Application */Block.__(2, [
                              r1,
                              match$3[0]
                            ])]);
              }
            } else {
              var r1$1 = match$2[0];
              if (match$3.tag) {
                return /* Result */Block.__(0, [/* Application */Block.__(2, [
                              r1$1,
                              match$3[0]
                            ])]);
              } else {
                return /* NoResult */Block.__(1, [/* Application */Block.__(2, [
                              r1$1,
                              t2
                            ])]);
              }
            }
          } else {
            return /* Result */Block.__(0, [match$1[0]]);
          }
      
    }
  } else {
    return /* Result */Block.__(0, [t[0]]);
  }
}

exports.HeadProcException = HeadProcException;
exports.procToString = procToString;
exports.flattenProcBranch = flattenProcBranch;
exports.isProcBranch = isProcBranch;
exports.makeProcBranch = makeProcBranch;
exports.$$eval = $$eval;
exports.evalHelper = evalHelper;
/* No side effect */
