// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var React = require("react");
var NativeProcedures$ReactHooksTemplate = require("./NativeProcedures.bs.js");

function primitive_to_string(p) {
  if (p.tag) {
    return p[0];
  } else {
    return String(p[0]);
  }
}

function termsToEl(t) {
  switch (t.tag | 0) {
    case 0 : 
        var s = t[0];
        var c;
        switch (s.tag | 0) {
          case 0 : 
              c = primitive_to_string(s[0]);
              break;
          case 1 : 
          case 2 : 
              c = s[0];
              break;
          case 3 : 
              c = NativeProcedures$ReactHooksTemplate.procToString(s[0]);
              break;
          
        }
        return React.createElement("span", {
                    style: {
                      color: "green"
                    }
                  }, c);
    case 1 : 
        return React.createElement("span", undefined, "(\\" + (t[0] + " -> "), termsToEl(t[1]), ")");
    case 2 : 
        var t1 = t[0];
        var exit = 0;
        switch (t1.tag | 0) {
          case 0 : 
              var match = t1[0];
              if (match.tag === 3) {
                return React.createElement("span", undefined, "(", termsToEl(/* Token */Block.__(0, [/* Procedure */Block.__(3, [match[0]])])), " ", termsToEl(t[1]), ")");
              } else {
                exit = 1;
              }
              break;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          return React.createElement("span", undefined, termsToEl(t1), " ", termsToEl(t[1]));
        }
        break;
    
  }
}

function substitution(_body, placeholder, substitute) {
  while(true) {
    var body = _body;
    switch (body.tag | 0) {
      case 0 : 
          var match = body[0];
          if (match.tag === 2) {
            var s = match[0];
            var match$1 = s === placeholder;
            if (match$1) {
              return substitute;
            } else {
              return /* Token */Block.__(0, [/* Variable */Block.__(2, [s])]);
            }
          } else {
            return body;
          }
      case 1 : 
          var t = body[1];
          var s$1 = body[0];
          var match$2 = s$1 === placeholder;
          if (match$2) {
            _body = t;
            continue ;
          } else {
            return /* Abstraction */Block.__(1, [
                      s$1,
                      substitution(t, placeholder, substitute)
                    ]);
          }
      case 2 : 
          return /* Application */Block.__(2, [
                    substitution(body[0], placeholder, substitute),
                    substitution(body[1], placeholder, substitute)
                  ]);
      
    }
  };
}

function etaConvert(t) {
  switch (t.tag | 0) {
    case 1 : 
        var match = t[1];
        switch (match.tag | 0) {
          case 0 : 
          case 1 : 
              return t;
          case 2 : 
              var match$1 = match[1];
              switch (match$1.tag | 0) {
                case 0 : 
                    var match$2 = match$1[0];
                    if (match$2.tag === 2) {
                      var match$3 = t[0] === match$2[0];
                      if (match$3) {
                        return match[0];
                      } else {
                        return t;
                      }
                    } else {
                      return t;
                    }
                case 1 : 
                case 2 : 
                    return t;
                
              }
          
        }
    case 0 : 
    case 2 : 
        return t;
    
  }
}

function hasEta(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return false;
      case 1 : 
          var t1 = t[1];
          switch (t1.tag | 0) {
            case 0 : 
            case 1 : 
                _t = t1;
                continue ;
            case 2 : 
                var match = t1[1];
                switch (match.tag | 0) {
                  case 0 : 
                      var match$1 = match[0];
                      if (match$1.tag === 2) {
                        return t[0] === match$1[0];
                      } else {
                        _t = t1;
                        continue ;
                      }
                  case 1 : 
                  case 2 : 
                      _t = t1;
                      continue ;
                  
                }
            
          }
      case 2 : 
          if (hasEta(t[0])) {
            return true;
          } else {
            _t = t[1];
            continue ;
          }
      
    }
  };
}

function hasRedex(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return false;
      case 1 : 
          _t = t[1];
          continue ;
      case 2 : 
          var t1 = t[0];
          switch (t1.tag | 0) {
            case 1 : 
                return true;
            case 0 : 
            case 2 : 
                if (hasRedex(t1)) {
                  return true;
                } else {
                  _t = t[1];
                  continue ;
                }
            
          }
      
    }
  };
}

function betaReduce(t) {
  switch (t.tag | 0) {
    case 0 : 
    case 1 : 
        return t;
    case 2 : 
        var match = t[0];
        switch (match.tag | 0) {
          case 0 : 
              return t;
          case 1 : 
              return substitution(match[1], match[0], t[1]);
          case 2 : 
              return /* Application */Block.__(2, [
                        betaReduce(/* Application */Block.__(2, [
                                match[0],
                                match[1]
                              ])),
                        t[1]
                      ]);
          
        }
    
  }
}

function $$eval(t) {
  var stepped = false;
  var e = t;
  while(!stepped) {
    var match = NativeProcedures$ReactHooksTemplate.evalHelper(/* NoResult */Block.__(1, [e]));
    if (match.tag) {
      var r = match[0];
      if (hasEta(r)) {
        e = etaConvert(r);
        stepped = true;
      } else if (hasRedex(r)) {
        e = betaReduce(r);
        stepped = true;
      } else {
        e = r;
        stepped = true;
      }
    } else {
      e = match[0];
      stepped = true;
    }
  };
  return e;
}

exports.primitive_to_string = primitive_to_string;
exports.termsToEl = termsToEl;
exports.substitution = substitution;
exports.etaConvert = etaConvert;
exports.hasEta = hasEta;
exports.hasRedex = hasRedex;
exports.betaReduce = betaReduce;
exports.$$eval = $$eval;
/* react Not a pure module */
